---
title: "Terceiro Dia - Manipulando dados e gerando gráficos"
author: "Pedro Cavalcante"
date: "20 de fevereiro de 2019"
output: html_document
---

Agora vamos conhecer dois pacotes do Tidyverse, uma coleção de pacotes com uma filosofia em comum de programação simples e legível. Ele não lhe é totalmente estranha. Ontem usamos alguns pacotes desses pacotes, como ``readr``, ``haven`` e ``readxl``, todos focados em importar dados. Agora é a hora de manipula-los com o ``dplyr`` e gerar visualizações de alta qualidade com o ``ggplot2``.

# Manipulação de dados com do ``dplyr``

Você já observou que no R quando precisamos várias funções, empilhamos elas umas dentro das outras? Normalmente não é assim que estruturamos frases nem pensamos, então é uma maneira pouco intuitiva de escrever comandos. O ``dplyr`` traz, além de algumas funções úteis que veremos mais à frente, o operador ``%>%``, que chamamos de _pipe_. Ele "engata" funções umas nas outras. Por exemplo, lembra de quando definimos uma semente aleatória usando a data e hora em que o programa roda?

```{R}
set.seed(as.numeric(Sys.time()))
```

Usando pipes, esse mesmo código ficaria:

```{R, message = FALSE, warning = FALSE}
library(dplyr)

Sys.time() %>%
  as.numeric() %>%
   set.seed()

### pular linhas é opcional

Sys.time() %>% as.numeric() %>% set.seed()
```

Na sessão anterior definimos uma amostra de uma variável aleatória $X$ e além de obter estatísticas descritivas também rodamos um teste de Shapiro-Wilk. O código era assim:

```{R, eval = FALSE}

X = rnorm(n = 2000,
          mean = 2,
          sd = sqrt(8))

sd(X) # desvio-padrão dos dados
var(X) # variância dos dados
mean(X) # média dos dados
sample(X, size = 7) # 7 elementos aleatoriamente escolhidos de X

shapiro.test(X) # teste de Shapiro-Wilk de normalidade de dados

```

Com pipes ele ficaria assim:

```{R, eval = FALSE}
X = rnorm(n = 2000,
          mean = 2,
          sd = sqrt(8))

X %>% sd()
X %>% var()
X %>% mean()
X %>% sample(7)
X %>% shapiro.test()

```

Há quem prefira escrever com pipes algumas linhas - em particular as com muitas funções juntas - porque torna o código mais legível. É mais intuitivo ler um comando como uma sequência de instruções engatadas, pelo menos em comparação com funções empilhadas. 

Outro uso muito comum do ``dplyr`` é gerar bases de dados derivadas de outras. A função ``group_by()`` por exemplo nos permite agrupar os dados com base em alguma variável. ``summarise()`` permite criação de variáveis novas que dependem de outras já contidas na base original. ``filter()`` nos permite filtrar

Para ilustrar essas funcionalidades vamos usar dados da base Penn World Tables 9.0 com vários agregados macroeconômicos. É bom ler a documentação da base sempre que for usar, mas adianto que as variáveis ``csh_`` informam parcela do PIB em um componente específico da Demanda Agregada. Vamos montar uma nova base com dados agrupados do mundo, por década, mostrando como evoluiu a participação média do governo e do setor externo nas economias do mundo. 

```{R}
library(pwt9)

data("pwt9.0")


# primeiro criaremos uma variável com a década da observação
pwt9.0$decada = ifelse(pwt9.0$year - 1900 < 60, "50", 
                       ifelse(pwt9.0$year - 1900 < 70, "60",
                        ifelse(pwt9.0$year - 1900 < 80, "70",
                         ifelse(pwt9.0$year - 1900 < 90, "80",
                          ifelse(pwt9.0$year - 1900 < 100, "90",
                           ifelse(pwt9.0$year - 1900 < 110, "00", "10")))))) %>% factor()

expor_governo = pwt9.0 %>% 
                  group_by(decada) %>%
                  summarise(Governo = mean(csh_g, na.rm = TRUE),
                            Exportacoes = mean(csh_x, na.rm = TRUE))

print(expor_governo)

```













# Gráficos com o ``ggplot2``



```{R, eval = FALSE, echo = FALSE}
## grafando distribuições
library(ggplot2)
ggplot(data = data.frame(x = c(-10,30)), aes(x=x)) + 
  stat_function(fun = dnorm, args = list(mean = 10, sd = 5)) + 
  ##stat_function() para funções
  ##importante manter essa sintaxe, passar uma lista com argumentos
  ylab("f(x)") + 
  ggtitle("Gráfico da densidade de uma N(10,25)")



## acumulada da normal

ggplot(data = data.frame(x = c(-10,30)), aes(x=x)) + 
  stat_function(fun = pnorm, args = list(mean = 10, sd = 5)) + 
  ylab("F(x)") + 
  ggtitle("Gráfico da distribuição acumulada de uma N(10,25)")


#gerando amostra
base = data.frame(amostra = rnorm(300,10,5))

#Fazendo o histograma da amosytra gerada acima
ggplot(data = base, aes(x = amostra)) + 
  geom_histogram(aes(y = ..density..), bins = 10) +
  stat_function(fun = dnorm, args = list(mean = 10, sd = 5))

##### MONTANDO GRID

library(gridExtra)

#Gráfico da densidade de X
graf1 = ggplot(data = data.frame(x = c(-10,30)), aes(x=x)) + stat_function(fun = dnorm, args = list(mean = 10, sd = 5)) + ylab("f(x)") 

#Gráfico de F(x)
graf2 = ggplot(data = data.frame(x = c(-10,30)), aes(x=x)) + stat_function(fun = pnorm, args = list(mean = 10, sd = 5)) + ylab("F(x)")

#Histograma da amostra
graf3 = ggplot(data = base, aes(x = amostra)) + geom_histogram(aes(y = ..density..), bins = 10) + stat_function(fun = dnorm, args = list(mean = 10, sd = 5), col = "red") + xlab(x)

grid.arrange(graf1,graf2,graf3, ncol = 2)
```
