setwd("C:/Users/Pichau/Desktop/petR/Aula 1 - Introdução e Sintaxe")
cite(rootSolve)
cite("rootSolve")
knitr::opts_chunk$set(echo = TRUE)
install.packages("rootSolve")
library(rootSolve)
cite("rootSolve")
citation(rootSolve)
citation("rootSolve")
2 + 2 = 4
2 + 2 == 4
2 + 2 != 4 # agora se é diferente
2 + 2 > 3 # maior
2 + 2 < 3 # menor
TRUE == FALSE
a = 2 # definindo um objeto a como 2
b <- 2 # o mesmo com b, usando o sinal <-
a == b # teste lógico
print(a) # retorna no console o valor de a
exp(3) # exponencial
factorial(4) #fatorial
choose(4, 2) #permutação
seq(from = 1,
to = 10,
by = 2) #sequência de-para com passo 2
seq(1, 10, 2) # o mesmo resultado sem especificar qual argumento é qual
c = seq (1, 5, 1)
print(c)
class(a)
str(a)
class(c)
str(c)
A = c(2,2) # A é um vetor de duas dimensões em que cada entrada é um 2
print(A) # printamos no console
class(A) # descobrimos a classe
str(A) # inspecionamos a estrutura
A = vector(2,2) # A é um vetor de duas dimensões em que cada entrada é um 2
A = c(2,2) # A é um vetor de duas dimensões em que cada entrada é um 2
print(A) # printamos no console
class(A) # descobrimos a classe
str(A) # inspecionamos a estrutura
A = as.vector(A)
print(A) # printamos no console
class(A) # descobrimos a classe
str(A) # inspecionamos a estrutura
A = c(2,2) # A é um vetor de duas dimensões em que cada entrada é um 2
is.vector(A)
H = matrix(B, E)
(B = c(2, -3, 5, 8))
C = c("um", "dois", "madeira", "peixe", "PET-UFF", "Niterói")
D = c(TRUE, FALSE, TRUE, FALSE, FALSE)
E = c(1, 3, 4, 9)
F_ = B*E # multiplicação de vetores
# nunca declare um objeto chamado F ou T porque são os símbolos de verdadeiro e falso
B*E # podemos também somente recuperar a conta se não quisermos printar F_
G = ifelse(C == "PET-UFF",
"Entrada do PET",
"Não é a Entrada do PET")
print(G)
H = matrix(B, E)
H
H = matrix(B, E,
nrow = 4)
H
B
E
H = matrix(B, E,
nrow = 2,
ncol = 4)
H
H = c(1, 3)
I = c(2, 4)
J = matrix(H, I,     # vetores
nrow = 2, # número de linhas
ncol = 2) # número de colunas
J
H = c(1, 3, 2, 4)
I = matrix(H,     # vetor
nrow = 2, # número de linhas
ncol = 2) # número de colunas
I
K = matrix(J,
ncol = 2)
K
J = c(2, 1, 5, 3)
K = matrix(J,
ncol = 2)
K
I %*% K
eigen(I) #autovalores e autovetores da matriz
eigen(I) #autovalores e autovetores da matriz
class(eigen(I)) #autovalores e autovetores da matriz
elemento1 = seq(1, 100)
base = data.frame(primeiro = elemento1,
segundo = elemento2)
elemento2 = seq(50, 150)
base = data.frame(primeiro = elemento1,
segundo = elemento2)
elemento2 = seq(50, 149)
base = data.frame(primeiro = elemento1,
segundo = elemento2)
base$terceiro = base$primeiro + base$segundo
base$terceiro = base$primeiro + base$segundo
mean(base$terceiro) # média
median(base$terceiro) # mediana
summary(base$terceiro) # sumário estatístico
median(base$primeiro) # mediana
mean(base$terceiro) # média
summary(base$terceiro) # sumário estatístico
summary(base$segundo) # sumário estatístico
lista = list(primeiro = base,
segundo = seq(1, 10),
terceiro = "a")
help(seq)
auto = eigen(I) #autovalores e autovetores da matriz
print(auto)
base[1,2] # pega o elemento na primeira linha e segunda coluna
base[1,]
base[,2]
knitr::opts_chunk$set(echo = TRUE)
C2 = c("alto", "baixo", "alto", "baixo", "baixo")
C2 = factor(C2)
C2
C2 = c("PET", "Atlética", "PET", "Goal", "Opção", "PET", "Opção", "Atlética", "Opção", "PET")
C2 = factor(C2)
C2
meta = 200
vendas_mensais = c(20, 15, 18, 25, 30, 12, 11, 19, 18, 20, 16, 22)
if(vendas_mensais > meta) {
print("Meta de vendas cumprida")
}
if(sum(vendas_mensais) > meta) {
print("Meta de vendas cumprida")
}
